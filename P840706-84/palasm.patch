# patch for PALASM1-ARCHIVE
# 
# This file is part of PALASM1-ARCHIVE
# 
# PALASM1-ARCHIVE is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# PALASM1-ARCHIVE is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with PALASM1-ARCHIVE.  If not, see <https://www.gnu.org/licenses/>.
#
# Author: Andreas Heitmann
# Date: 2025-01-08
#
diff --strip-trailing-cr --unified orig/pal84.for new/pal84.for
--- orig/pal84.for	2025-01-08 16:28:27.648654100 +0100
+++ new/pal84.for	2025-01-08 16:28:37.004999600 +0100
@@ -50,7 +50,7 @@
       RETURN
       END
 C
-      INTEGER*2 FUNCTION ANDRD(X,Y)
+      INTEGER*1 FUNCTION ANDRD(X,Y)
       INTEGER*2 X,Y,PAT
 C
       INTEGER*1 ISAVE(256,128),TSTVEC(375,84),ANDAR(256,64)
@@ -63,7 +63,7 @@
       RETURN
       END
 C
-      INTEGER*2 FUNCTION LFSRD(X,Y)
+      LOGICAL FUNCTION LFSRD(X,Y)
       INTEGER*2 X,Y,PAT
 C
       INTEGER*1 ISAVE(256,128),TSTVEC(375,84),ANDAR(256,64)
@@ -76,6 +76,47 @@
       RETURN
       END
 C
+      INTEGER FUNCTION KCLOS(LUN)
+      INTEGER*1 LUN
+      LOGICAL FLAG
+      FLAG=IOCLOS (LUN)
+      KCLOS=0
+      IF (FLAG) KCLOS=1
+      RETURN
+      END
+C
+      INTEGER FUNCTION KREAD(LUN,L1,L2,FILE)
+      IMPLICIT INTEGER*1 (A-Z)
+      CHARACTER*1 FILE(20)
+      LOGICAL FLAG
+      J=21
+10    J=J-1
+      IF (J .EQ. 0) GOTO 20
+      IF (FILE(J) .NE. ' ') GOTO 20
+      FILE(J)=CHAR(0)
+      GOTO 10
+20    FLAG=IOREAD (LUN,L1,L2,FILE)
+      KREAD=0
+      IF (FLAG) KREAD=1
+      RETURN
+      END
+C
+      INTEGER FUNCTION KWRIT(LUN,L1,L2,FILE)
+      IMPLICIT INTEGER*1 (A-Z)
+      CHARACTER*1 FILE(20)
+      LOGICAL FLAG
+      J=21
+10    J=J-1
+      IF (J .EQ. 0) GOTO 20
+      IF (FILE(J) .NE. ' ') GOTO 20
+      FILE(J)=CHAR(0)
+      GOTO 10
+20    FLAG=IOWRIT (LUN,L1,L2,FILE)
+      KWRIT=0
+      IF (FLAG) KWRIT=1
+      RETURN
+      END
+C
 C$$ PAL84.FOR
 C PALASM84 FOR 64R32 FIRST REV ON 12/14/83
 C*************************
@@ -150,29 +191,33 @@
 C     MAIN PROGRAM
 C
       IMPLICIT INTEGER*1 (A-Z)
-      INTEGER*1 CPG(9000),CLN(80)
+      CHARACTER*1 CPG(9000),CLN(80)
       INTEGER*2 LOF(350),LLN(350),LNPTR,LNMAX
       COMMON /PDS/ LNMAX,LOF,LLN
       COMMON /LINBUF/ CLN,CPG
       COMMON /LUNIT/ CONINP,CONOUT,FILINP,FILOUT,PMS,POF,PDF,ROC,RPD
 C
-      INTEGER*1 FILE1(20),FILE2(20)
-      INTEGER ITYPE,IONE,IBL
-      INTEGER IC,IL,IC1,J,K,I,I88PRO,I8PRO,OUTPIN
-      INTEGER IPROD,COUNT,IBLOW,ILL,ILERR,IIL,IINPUT,ILE,ORCNT,IMATCH
+      CHARACTER*1 FILE1(20),FILE2(20)
+      INTEGER*2 IBL,IONE
+      INTEGER ITYPE
+      INTEGER*2 J,I
+      INTEGER IC,IL,IC1,K,I88PRO,I8PRO,OUTPIN
+      INTEGER*2 IPROD,IINPUT
+      INTEGER COUNT,IBLOW,ILL,ILERR,IIL,ILE,ORCNT,IMATCH
 C
-      INTEGER*1 IPAL(3),INAME(5),REST(72),PATN(80),TITLE(80),COMP(80)
+      CHARACTER*1 IPAL(3),INAME(5),REST(72),PATN(80),TITLE(80),COMP(80)
       COMMON/SPEC/ IPAL,INAME,REST,PATN,TITLE,COMP
 C
 C
       INTEGER*2 PARRY(375)
       LOGICAL LSA01(375,2),LTST(375)
-      COMMON /TEST/ LSA01,LTST,PARRY
+      COMMON /CTEST/ LSA01,LTST,PARRY
 C
       LOGICAL LORARY(2,256),LPOLAR(84),LBYPAS(84)
       COMMON /LFUSE/LORARY,LPOLAR,LBYPAS
 C
-      INTEGER*1 ISYM(8,84),IBUF(8,84),IPCNT(80),DDD(128),PPP(84)
+      CHARACTER*1 ISYM(8,84),IBUF(8,84)
+      INTEGER*1 IPCNT(84),DDD(128),PPP(84)
 C
       LOGICAL LBLANK,LLEFT,LAND,LOR,LSLASH,LEQUAL,LRIGHT,LXOR,LFIRST,
      1        LMATCH,LFSE(84),LBUF(84),LPROD(256),FLFUSE(4,2),FLFLG,
@@ -180,11 +225,25 @@
       COMMON  LBLANK,LLEFT,LAND,LOR,LSLASH,LEQUAL,LRIGHT,LXOR
       INTEGER IDESC,IFUNCT,IEND,SINGLE
       COMMON /FTEST/IFUNCT,IDESC,IEND
+      CHARACTER, PARAMETER :: TABP = CHAR(9)
+      CHARACTER, PARAMETER :: BELP = CHAR(7)
+      CHARACTER, PARAMETER :: FFEEDP = CHAR(12)
+      CHARACTER*1 E,O,T,P,B,D,H,S,
+     1     L,N,C,Q,U,F,Y,W
       DATA E/'E'/,O/'O'/,T/'T'/,P/'P'/,B/'B'/,D/'D'/,H/'H'/,S/'S'/,
      1     L/'L'/,N/'N'/,C/'C'/,Q/'Q'/,U/'U'/,F/'F'/,Y/'Y'/,W/'W'/
+      CHARACTER*1 BB,CC,DD,EE,FF,II,NN,
+     1     OO,PP,RR,SS,TT,UU,JJ
       DATA BB/'B'/,CC/'C'/,DD/'D'/,EE/'E'/,FF/'F'/,II/'I'/,NN/'N'/,
      1     OO/'O'/,PP/'P'/,RR/'R'/,SS/'S'/,TT/'T'/,UU/'U'/,JJ/'J'/
-      DATA BEL/007/,IONE/1/,IBLANK/' '/,IBL/0/,TAB/9/,FFEED/12/
+      CHARACTER*1 BEL,IBLANK,TAB,FFEED
+      DATA BEL/BELP/,IONE/1/,IBLANK/' '/,IBL/0/,TAB/TABP/,FFEED/FFEEDP/
+      LOGICAL LPRD
+      CHARACTER*1 IOP
+      INTEGER KREAD, KWRIT, KCLOS
+      LOGICAL DOIT
+      INTEGER*1 ITWO,IZERO
+      DATA ITWO/2/,IZERO/0/
 C
 C
       CALL IOINIT
@@ -206,14 +265,14 @@
     2 FORMAT(/,' WHAT IS THE SOURCE FILENAME (d:filename.ext) ?: '$)
       READ(CONINP,3) (FILE1(I),I=1,20)
     3 FORMAT(20A1)
-      IF(KREAD(FILINP,2,0,FILE1) .NE. 0) GO TO 130
+      IF(KREAD(FILINP,ITWO,IZERO,FILE1) .NE. 0) GO TO 130
       WRITE(CONOUT,333)
   333 FORMAT(/,' OUTPUT FILENAME -',
      1         ' PRESS <ENTER> FOR NO OUTPUT FILE ?: '$)
       READ(CONINP,3) (FILE2(I),I=1,20)
       LUN=CONOUT
       IF(FILE2(1).EQ.IBLANK) GO TO 9
-      IF(KWRIT(FILOUT,2,0,FILE2) .NE. 0) GO TO 130
+      IF(KWRIT(FILOUT,ITWO,IZERO,FILE2) .NE. 0) GO TO 130
       LUN=FILOUT
     9 RPD=FILINP
       POF=LUN
@@ -266,7 +325,7 @@
 C
       LNPTR=0
       LNMAX=0
-10    READ(RPD,5,ENDFILE=15) (CLN(IC),IC=1,80)
+10    READ(RPD,5,END=15) (CLN(IC),IC=1,80)
 5     FORMAT(80A1)
       WRITE (CONOUT,9001)
       LNMAX=LNMAX+1
@@ -338,7 +397,7 @@
 C     GET 84 PIN NAMES
    17 DO 20 J=1,84
    20     CALL GETSYM(LFSE,ISYM,J,IC,IL,FLFLG)
-          IF(.NOT.(LEQUAL.OR.LLEFT.OR.LAND.OR.LOR.OR.LRIGHT)) GO TO 24
+           IF(.NOT.(LEQUAL.OR.LLEFT.OR.LAND.OR.LOR.OR.LRIGHT)) GO TO 24
               WRITE(PMS,23)
    23         FORMAT(/, ' LESS THAN 84 PIN NAMES IN PIN LIST')
               STOP
@@ -502,7 +561,7 @@
       READ(ROC,120) IOP
   120 FORMAT(A1)
 C
-      IF (IOP .GT. Y) IOP=IOP-32
+      IF (IOP .GT. Y) IOP=CHAR(ICHAR(IOP)-ICHAR(' '))
       IF(POF.NE.CONOUT) WRITE(POF,125)
   125 FORMAT('1')
 C
@@ -536,18 +595,22 @@
 C     THIS SUBROUTINE GENERATES TEST VECTORS AUTOMATICALLY
 C     FOR THE FUSEPLOT PERSONALISED FOR A PARTICULAR APPLICATION
       IMPLICIT INTEGER*1 (A-Z)
-      INTEGER I,J,OUT,K,PT1,PT11,PT12,TSTCNT,IDONT,IONE,IZERO
+      INTEGER*2 I,J,K,PT1,PT11,PT12,IDONT,IONE,IZERO
+      INTEGER OUT,TSTCNT
 C
       INTEGER*2 PARRY(375)
       LOGICAL LSA01(375,2),LTST(375)
-      COMMON /TEST/ LSA01,LTST,PARRY
+      COMMON /CTEST/ LSA01,LTST,PARRY
 C
       LOGICAL LORARY(2,256),LPOLAR(84),LBYPAS(84)
       COMMON /LFUSE/LORARY,LPOLAR,LBYPAS
 C
       COMMON /LUNIT/ CONINP,CONOUT,FILINP,FILOUT,PMS,POF,PDF,ROC,RPD
+      CHARACTER*1 L,H,DASH,CROSS,ZERO,
+     1        ONE,DONT,CLOCK,P
       DATA    L/'L'/,H/'H'/,DASH/'-'/,CROSS/'X'/,ZERO/'0'/,
      1  ONE/'1'/,DONT/'D'/,CLOCK/'C'/,P/'P'/,IDONT/3/,IONE/1/,IZERO/0/
+      LOGICAL LFSRD
 C     INITIALISE THE LAND TO LOGICAL DONT CARE
       DO 5 I=1,256
       DO 5 J=1,64
@@ -592,15 +655,15 @@
      5         '123456789012345678901234','  ',' LSA0',' LSA1')
 
       GO TO 13
-   11 IF((LFSRD(I,J)).AND.(.NOT.LFSRD(I+1,J)))
+   11 IF((LFSRD(I,J)).AND.(.NOT.LFSRD(I+IONE,J)))
      1    CALL ANDWRT(J,K,IONE)
-      IF((.NOT.LFSRD(I,J)).AND.(LFSRD(I+1,J)))
+      IF((.NOT.LFSRD(I,J)).AND.(LFSRD(I+IONE,J)))
      2    CALL ANDWRT(J,K,IZERO)
       K=K+1
       GO TO 10
-   12 IF((LFSRD(I,J)).AND.(.NOT.LFSRD(I+1,J)))
+   12 IF((LFSRD(I,J)).AND.(.NOT.LFSRD(I+IONE,J)))
      1    CALL ANDWRT(J,K,IZERO)
-      IF((.NOT.LFSRD(I,J)).AND.(LFSRD(I+1,J)))
+      IF((.NOT.LFSRD(I,J)).AND.(LFSRD(I+IONE,J)))
      2    CALL ANDWRT(J,K,IONE)
       K=K+1
       GO TO 10
@@ -619,7 +682,7 @@
       DO 6 I=1,375
       DO 6 J=1,84
       CALL TSTWRT(I,J,IDONT)
-      PARRY(I)=ZERO
+      PARRY(I)=0
       LTST(I)=.FALSE.
       LSA01(I,1)=.FALSE.
       LSA01(I,2)=.FALSE.
@@ -646,7 +709,7 @@
       DO 16 I=1,375
       DO 16 J=1,84
       CALL TSTWRT(I,J,IDONT)
-      PARRY(I)=ZERO
+      PARRY(I)=0
       LTST(I)=.FALSE.
       LSA01(I,1)=.FALSE.
       LSA01(I,2)=.FALSE.
@@ -670,13 +733,16 @@
 C     THIS SUBTOUTINE TRANSFERS THE VECTOR IN LAND MATRIX TO
 C     APPROPRIATE PLACES IN THE TSTVEC MATRIX
       IMPLICIT INTEGER*1 (A-Z)
-      INTEGER I,J,OUT,PT1,TMP
+      INTEGER*2 I,PT1
+      INTEGER J,OUT
 C
       INTEGER*2 PARRY(375)
       LOGICAL LSA01(375,2),LTST(375)
-      COMMON /TEST/ LSA01,LTST,PARRY
+      COMMON /CTEST/ LSA01,LTST,PARRY
 C
-      INTEGER XA(64),XB(64)
+      INTEGER*2 XA(64),XB(64)
+      INTEGER*1 ANDRD
+      INTEGER*2 TMP
 C
 C23456789A123456789B123456789C123456789D123456789E123456789F123456789G123
       DATA XA/1,2,3,4,5,6,7,8,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
@@ -700,16 +766,18 @@
 C     EACH PRODUCT TERM IS SUCCESSIVELY 'TURNED ON'. THUS THESE
 C     VECTORS IN EFFECT TEST FOR A FUSELINK SA0
       IMPLICIT INTEGER*1 (A-Z)
-      INTEGER I,J,K,OUT,PT1,PT11,L
+      INTEGER*2 I,PT1,PT11,K
+      INTEGER J,OUT,L
 C
       INTEGER*2 PARRY(375)
       LOGICAL LSA01(375,2),LTST(375)
-      COMMON /TEST/ LSA01,LTST,PARRY
+      COMMON /CTEST/ LSA01,LTST,PARRY
 C
       LOGICAL LORARY(2,256),LPOLAR(84),LBYPAS(84)
       COMMON /LFUSE/LORARY,LPOLAR,LBYPAS
 C
       LOGICAL  COVERF
+      CHARACTER*1 ZERO,ONE,DONT
       DATA     ZERO/'0'/,ONE/'1'/,DONT/'D'/
 C     CHECK WHETHER A PARTICULAR PRODUCT TERM IS USED OR NOT FOR
 C     THAT PARTICULAR OUTPUT
@@ -739,16 +807,19 @@
 C     SET OF TEST VECTORS WILL TEST FOR EACH FUSE FOR SA1
 C     TEST. THE FAULT FREEE OUTPUT SHOULD BE ZERO.
       IMPLICIT INTEGER*1 (A-Z)
-      INTEGER J,I,OUT,PT1,PT11,PT12,K,L,DONT,ONE,ZERO
+      INTEGER*2 J,I,PT1,PT11,PT12,K
+      INTEGER OUT,L
 C
       INTEGER*2 PARRY(375)
       LOGICAL LSA01(375,2),LTST(375)
-      COMMON /TEST/ LSA01,LTST,PARRY
+      COMMON /CTEST/ LSA01,LTST,PARRY
 C
       LOGICAL LORARY(2,256),LPOLAR(84),LBYPAS(84)
       COMMON /LFUSE/LORARY,LPOLAR,LBYPAS
 C
+      INTEGER*2 ZERO,ONE,DONT
       DATA    ZERO/0/,ONE/1/,DONT/3/
+      INTEGER*1 ANDRD
       L=K+15
       DO 15 I=K,L
       IF((MOD(OUT,2).EQ.0).AND.(LORARY(1,I))
@@ -792,14 +863,18 @@
 C     THEN VECTORS V1 AND V2 ARE MADE MUTUALLY EXCLSIVE BY
 C     CHANGING 'X' TO '0' OR '1'
       IMPLICIT INTEGER*1 (A-Z)
-      INTEGER J,I,L,PT1,PT12,PT11,DONT,ZERO,ONE,TMP
+      INTEGER*2 I,J,L,TMP
+      INTEGER*2 PT1,PT12,PT11
       LOGICAL  COVERF
 C
       INTEGER*2 PARRY(375)
       LOGICAL LSA01(375,2),LTST(375)
-      COMMON /TEST/ LSA01,LTST,PARRY
+      COMMON /CTEST/ LSA01,LTST,PARRY
 C
+      INTEGER*2 ZERO,ONE,DONT
       DATA    ZERO/0/,ONE/1/,DONT/3/
+      INTEGER*2 TSTRD
+      INTEGER*2,PARAMETER :: P375 = 375
 C
       IF ((PT11+PT1) .LT. 375) GOTO 3
       WRITE (6,8005) PT11,PT12,PT1
@@ -810,22 +885,22 @@
 3     DO 5 I=1,PT11
       DO 5 J=1,84
       TMP=TSTRD(I,J)
-    5 CALL TSTWRT(375-I,J,TMP)
+    5 CALL TSTWRT(P375-I,J,TMP)
       DO 25  I=1,PT11
       DO 25  J=1,PT11
       IF (J.EQ.I) GO TO 25
 C     INITIALLY ALL VECTORS ARE ASSUMED TO BE COVERED
       COVERF=.TRUE.
       DO 10 L=1,84
-      IF(((TSTRD(375-I,L).EQ.ZERO).AND.(TSTRD(375-J,L).EQ.ONE))
-     1  .OR.((TSTRD(375-I,L).EQ.ONE).AND.(TSTRD(375-J,L).EQ.ZERO)))
+      IF(((TSTRD(P375-I,L).EQ.ZERO).AND.(TSTRD(P375-J,L).EQ.ONE))
+     1  .OR.((TSTRD(P375-I,L).EQ.ONE).AND.(TSTRD(P375-J,L).EQ.ZERO)))
      2 COVERF=.FALSE.
    10 CONTINUE
       IF (.NOT.COVERF) GO TO 25
    15 DO 20 L=1,84
-      IF ((TSTRD(375-I,L).EQ.DONT).AND.(TSTRD(375-J,L).EQ.ZERO)
+      IF ((TSTRD(P375-I,L).EQ.DONT).AND.(TSTRD(P375-J,L).EQ.ZERO)
      1 .AND.(COVERF)) GO TO 22
-      IF((TSTRD(375-I,L).EQ.DONT).AND.(TSTRD(375-J,L).EQ.ONE)
+      IF((TSTRD(P375-I,L).EQ.DONT).AND.(TSTRD(P375-J,L).EQ.ONE)
      1 .AND.(COVERF)) GO TO 24
    20 CONTINUE
       IF(COVERF) GO TO 25
@@ -843,19 +918,24 @@
 C
       SUBROUTINE PROUT(PT11,PT12,PT1,OUT)
       IMPLICIT INTEGER*1 (A-Z)
-      INTEGER I,J,K,LL,L,PT1,PT11,PT12,OUT,PT,IONE,IZE,IDN
+      INTEGER*2 I,L,PT1,PT11,PT12
+      INTEGER J,K,LL,OUT,PT,IONE,IZE,IDN
 C
       INTEGER*1 IPAL(3),INAME(5),REST(72),PATN(80),TITLE(80),COMP(80)
       COMMON/SPEC/ IPAL,INAME,REST,PATN,TITLE,COMP
 C
       INTEGER*2 PARRY(375)
       LOGICAL LSA01(375,2),LTST(375)
-      COMMON /TEST/ LSA01,LTST,PARRY
+      COMMON /CTEST/ LSA01,LTST,PARRY
 C
-      INTEGER*1 TMP(86)
+      CHARACTER*1 TMP(86)
       COMMON /LUNIT/ CONINP,CONOUT,FILINP,FILOUT,PMS,POF,PDF,ROC,RPD
+
+      CHARACTER*1 ZERO,ONE,DONT,DASH,CROSS,
+     1        P,CLOCK
       DATA    ZERO/'0'/,ONE/'1'/,DONT/'D'/,DASH/'-'/,CROSS/'X'/,
      1        P/'P'/,CLOCK/'C'/,IONE/1/,IZE/0/,IDN/3/
+      INTEGER*2 TSTRD
       DO 35 I=1,PT11
       WRITE(POF,16)OUT,PARRY(I)-1
    16 FORMAT(/,1X,I3,1X,I3)
@@ -928,16 +1008,19 @@
 C     PROPER POLARITY IS CONSIDERED BY EVALUATING THE LFSE AND LFS1.
       IMPLICIT INTEGER*1 (A-Z)
       INTEGER J,I,IMAX,IC,IL
-      INTEGER*1  IPIN(84),FVECT(64),FCVECT(16)
+      CHARACTER*1  FVECT(64),FCVECT(16)
+      INTEGER*1  IPIN(84)
       LOGICAL  LFSE(84),LFS1(84)
 C
-      INTEGER*1 CPG(9000),CLN(80)
+      CHARACTER*1 CPG(9000),CLN(80)
       INTEGER*2 LOF(350),LLN(350),LNPTR,LNMAX
       COMMON /PDS/ LNMAX,LOF,LLN
       COMMON /LINBUF/ CLN,CPG
       COMMON /LUNIT/ CONINP,CONOUT,FILINP,FILOUT,PMS,POF,PDF,ROC,RPD
 C
+      CHARACTER*1 H,L,X,Z,C,DASH
       DATA     H/'H'/,L/'L'/,X/'X'/,Z/'Z'/,C/'C'/,DASH/'-'/
+      CHARACTER*1 COMENT,BLANK,ONE,ZERO,DONT
       DATA     COMENT/';'/,BLANK/' '/,ONE/'1'/,ZERO/'0'/,DONT/'D'/
 C     GO PASSED THE COMMENT LINES
     5 IF(CPG(LOF(IL)+IC).NE.COMENT) GO TO 6
@@ -979,13 +1062,13 @@
       IF(CPG(LOF(IL)+IC).EQ.X) FVECT(V)=DONT
       IF(CPG(LOF(IL)+IC).EQ.Z) FVECT(V)=Z
       IF((CPG(LOF(IL)+IC).EQ.H)
-     1 .AND.(LFSE(J).NE.LFS1(I))) FVECT(V)=ZERO
+     1 .AND.(LFSE(J).NEQV.LFS1(I))) FVECT(V)=ZERO
       IF((CPG(LOF(IL)+IC).EQ.H)
-     1 .AND.(LFSE(J).EQ.LFS1(I))) FVECT(V)=ONE
+     1 .AND.(LFSE(J).EQV.LFS1(I))) FVECT(V)=ONE
       IF((CPG(LOF(IL)+IC).EQ.L)
-     1 .AND.(LFSE(J).NE.LFS1(I))) FVECT(V)=ONE
+     1 .AND.(LFSE(J).NEQV.LFS1(I))) FVECT(V)=ONE
       IF((CPG(LOF(IL)+IC).EQ.L)
-     1 .AND.(LFSE(J).EQ.LFS1(I))) FVECT(V)=ZERO
+     1 .AND.(LFSE(J).EQV.LFS1(I))) FVECT(V)=ZERO
    10 CONTINUE
       RETURN
       END
@@ -996,15 +1079,16 @@
 C UNDER AN INPUT PIN. FOR E.G. 'X' UNDER /PIN1 IS LOGICAL '0' IN
 C IN THE ANDAR AND 'X' UNDER PIN1 IS LOGICAL '1' IN THE ANDAR
       IMPLICIT INTEGER*1 (A-Z)
-      INTEGER I,J,K,ONE,ZERO
+      INTEGER*2 I,J,K,ONE,ZERO
 C
       INTEGER*2 PARRY(375)
       LOGICAL LSA01(375,2),LTST(375)
-      COMMON /TEST/ LSA01,LTST,PARRY
+      COMMON /CTEST/ LSA01,LTST,PARRY
       LOGICAL LORARY(2,256),LPOLAR(84),LBYPAS(84)
       COMMON /LFUSE/LORARY,LPOLAR,LBYPAS
 C
       DATA    ONE/1/, ZERO/0/
+      LOGICAL LFSRD
       DO 10 J=1,256
       K=1
       DO 10 I=1,128,2
@@ -1026,15 +1110,15 @@
      7   (I.EQ.89).OR.(I.EQ.91).OR.(I.EQ.93).OR.(I.EQ.95)) GO TO 12
    10 CONTINUE
       RETURN
-   11 IF((LFSRD(I,J)).AND.(.NOT. LFSRD(I+1,J)))
+   11 IF((LFSRD(I,J)).AND.(.NOT. LFSRD(I+ONE,J)))
      1  CALL ANDWRT(J,K,ONE)
-      IF((.NOT.LFSRD(I,J)).AND.(LFSRD(I+1,J)))
+      IF((.NOT.LFSRD(I,J)).AND.(LFSRD(I+ONE,J)))
      2  CALL ANDWRT(J,K,ZERO)
       K=K+1
       GO TO 10
-   12 IF((LFSRD(I,J)).AND.(.NOT. LFSRD(I+1,J)))
+   12 IF((LFSRD(I,J)).AND.(.NOT. LFSRD(I+ONE,J)))
      1  CALL ANDWRT(J,K,ZERO)
-      IF((.NOT.LFSRD(I,J)).AND.(LFSRD(I+1,J)))
+      IF((.NOT.LFSRD(I,J)).AND.(LFSRD(I+ONE,J)))
      2  CALL ANDWRT(J,K,ONE)
       K=K+1
       GO TO 10
@@ -1047,11 +1131,11 @@
 C     ORDER OF INPUT PINS AND OUTPUT PINS. THIS IS DONE TO FACILITATE
 C     SIMULATION ALGORITHM.
       IMPLICIT INTEGER*1 (A-Z)
-      INTEGER J,I,DONT,TEMP
+      INTEGER*2 J,I,DONT,TEMP
 C
       INTEGER*2 PARRY(375)
       LOGICAL LSA01(375,2),LTST(375)
-      COMMON /TEST/ LSA01,LTST,PARRY
+      COMMON /CTEST/ LSA01,LTST,PARRY
       LOGICAL LORARY(2,256),LPOLAR(84),LBYPAS(84)
       COMMON /LFUSE/LORARY,LPOLAR,LBYPAS
 C
@@ -1099,39 +1183,51 @@
       SUBROUTINE TEST(LFSE,ISYM,IC,IL,ILE,FLFUSE,NVECT)
 C     THIS SUBROUTINE PERFORMS THE FUNCTION TABLE SIMULATION
 C      AND GENERATES TEST VECTORS
-      IMPLICIT INTEGER*1 (A-Z)
-      INTEGER J,I,C,K,IC,IL,ILE,IC1,IL1,IMATCH,IMAX
+C     IMPLICIT INTEGER*1 (A-Z)
+      INTEGER*2 I
+      INTEGER J,K,IC,IL,ILE,IC1,IL1,IMATCH,IMAX
 C
       INTEGER*2 PARRY(375)
       LOGICAL LSA01(375,2),LTST(375)
-      COMMON /TEST/ LSA01,LTST,PARRY
+      COMMON /CTEST/ LSA01,LTST,PARRY
 C
       INTEGER*1 IPAL(3),INAME(5),REST(72),PATN(80),TITLE(80),COMP(80)
       COMMON/SPEC/ IPAL,INAME,REST,PATN,TITLE,COMP
       LOGICAL LORARY(2,256),LPOLAR(84),LBYPAS(84)
       COMMON /LFUSE/LORARY,LPOLAR,LBYPAS
 C
-      INTEGER*1 ISYM(8,84),ISYM1(8,84),IBUF(8,84),FVECT(64),FCVECT(16),
-     1 IPIN(84),FPRE(32),FINPUT(32),FOTPUT(32),IPIN1(84)
-      INTEGER*1 OUTPUT(32),PREOUT(32)
-      INTEGER ROW,NVECT,ERROR
+      CHARACTER*1 ISYM(8,84),ISYM1(8,84),IBUF(8,84),FVECT(64),
+     1        FCVECT(16),FPRE(32)
+      CHARACTER*1 FOTPUT(32)
+      CHARACTER*1 FINPUT(32)
+      INTEGER*1 IPIN(84),IPIN1(84)
+      CHARACTER*1 OUTPUT(32),PREOUT(32)
+      INTEGER*1 NVECT
+      INTEGER ROW,ERROR
 C
       LOGICAL LBLANK,LLEFT,LAND,LOR,LSLASH,LEQUAL,LRIGHT,LXOR,LSAME,
      1        XORFND,LERR,LFSE(84),LFS1(84),FLG1,FLG2,
      2        FPOLAR(32),FLFUSE(4,2),LTEST(32),LMATCH,FLG3,FLG4
       COMMON  LBLANK,LLEFT,LAND,LOR,LSLASH,LEQUAL,LRIGHT,LXOR
 C
-      INTEGER*1 CPG(9000),CLN(80)
+      CHARACTER*1 CPG(9000),CLN(80)
       INTEGER*2 LOF(350),LLN(350),LNPTR,LNMAX
       COMMON /PDS/ LNMAX,LOF,LLN
       COMMON /LINBUF/ CLN,CPG
+      INTEGER*1 CONINP,CONOUT,FILINP,FILOUT,PMS,POF,PDF,ROC,RPD
       COMMON /LUNIT/ CONINP,CONOUT,FILINP,FILOUT,PMS,POF,PDF,ROC,RPD
 C
       INTEGER IDESC,IEND,IFUNCT
       COMMON /FTEST/ IFUNCT,IDESC,IEND
+      CHARACTER*1 IDASH,L,H,X,C,Z,N0,
+     1     N1,ERR,IBLANK,COMENT,DONT
       DATA IDASH/'-'/,L/'L'/,H/'H'/,X/'X'/,C/'C'/,Z/'Z'/,N0/'0'/,
      1     N1/'1'/,ERR/'?'/,IBLANK/' '/,COMENT/';'/,DONT/'D'/
-      DATA BEL/007/
+      CHARACTER*1, PARAMETER :: BELP = CHAR(7)
+      CHARACTER*1 BEL
+      DATA BEL/BELP/
+      LOGICAL FLFLG
+C
       DO 1 I=1,84
       IPIN1(I)=0
    1  CONTINUE   
@@ -1278,7 +1374,7 @@
 C
 C      THIS SUBROUTINE DEVIDES FVECTOR INTO FINPUT AND FOTPUT
 C
-        INTEGER*1 FVECT(64),FINPUT(32),FOTPUT(32)
+      CHARACTER*1 FVECT(64),FINPUT(32),FOTPUT(32)
       INTEGER I
 C
          DO 10 I=1,32
@@ -1328,17 +1424,19 @@
 C
 C***************************
        IMPLICIT INTEGER*1 (A-Z)
-      INTEGER J,I,M,INDEX,COUNT,IONE,IZE,IDN
+      INTEGER*2 J,I
+      INTEGER M,INDEX,COUNT,IONE,IZE,IDN
 C
       INTEGER*2 PARRY(375)
       LOGICAL LSA01(375,2),LTST(375)
-      COMMON /TEST/ LSA01,LTST,PARRY
+      COMMON /CTEST/ LSA01,LTST,PARRY
       LOGICAL LORARY(2,256),LPOLAR(84),LBYPAS(84)
       COMMON /LFUSE/LORARY,LPOLAR,LBYPAS
 C
-       INTEGER*1 FINPUT(32),FPRE(32),FCOMB(64),OUTPUT(32)
+      CHARACTER*1 FINPUT(32),FPRE(32),FCOMB(64),OUTPUT(32)
       COMMON /LUNIT/ CONINP,CONOUT,FILINP,FILOUT,PMS,POF,PDF,ROC,RPD
       LOGICAL  EVEN,TEST
+      CHARACTER*1 H,L,D,ZERO,ONE
       DATA H/'H'/,L/'L'/,D/'D'/,ZERO/'0'/,ONE/'1'/,IDN/3/,IONE/1/,IZE/0/
 C
 C
@@ -1453,7 +1551,8 @@
 C*************************
         IMPLICIT INTEGER*1 (A-Z)
       INTEGER I
-        INTEGER*1 OUTPUT(32),FOTPUT(32),CVECT(16),FPRE(32)
+      CHARACTER*1 OUTPUT(32),FOTPUT(32),CVECT(16),FPRE(32)
+      CHARACTER*1 Z,ZERO,ONE
       DATA Z/'Z'/,ZERO/'0'/,ONE/'1'/
       LOGICAL FLG1,FLG2,FLG3,FLG4
       COMMON /LUNIT/ CONINP,CONOUT,FILINP,FILOUT,PMS,POF,PDF,ROC,RPD
@@ -1515,7 +1614,7 @@
         IF(((CVECT(2).EQ.ONE).AND.(CVECT(1).EQ.ZERO))
      1   .OR.((CVECT(6).EQ.ONE).AND.(CVECT(5).EQ.ZERO))
      2   .OR.((CVECT(10).EQ.ONE).AND.(CVECT(9).EQ.ZERO))
-     3   .OR.((CVECT(14).EQ.ONE).AND.(CVECT(13).EQ.ZERI)))
+     3   .OR.((CVECT(14).EQ.ONE).AND.(CVECT(13).EQ.ZERO)))
      4    GO TO 1000
        GO TO 1500
  120   DO 125 I=25,32
@@ -1541,8 +1640,9 @@
 C
       IMPLICIT INTEGER*1 (A-Z)
       INTEGER I
-      INTEGER*1 OUTPUT(32),FPRE(32)
+      CHARACTER*1 OUTPUT(32),FPRE(32)
       LOGICAL BYPAS(4,2),LPOLAR(32)
+      CHARACTER*1 L,H,D,ZERO,ONE
       DATA L/'L'/,H/'H'/,D/'D'/,ZERO/'0'/,ONE/'1'/
 C
       DO 10 I=1,32
@@ -1582,8 +1682,10 @@
 C
       IMPLICIT INTEGER*1 (A-Z)
       INTEGER I
-      INTEGER*1 OUTPUT(32),FOTPUT(32)
+      CHARACTER*1 OUTPUT(32),FOTPUT(32)
       LOGICAL LTEST(32)
+      LOGICAL FLG1,FLG2,FLG3,FLG4
+      CHARACTER*1 D
       DATA D/'D'/
 C
       DO 1 I=1,32
@@ -1645,11 +1747,15 @@
 C FVECT(I) IS IN THE ORDER OF INPUT (FIRST 16) AND OUTPUT
 C
       IMPLICIT INTEGER*1 (A-Z)
-      INTEGER*1 IPIN1(84),FVECT(64),OUTPUT(32),FNCTBL,TEMP(84),NVECT,
+      CHARACTER*1 FVECT(64),OUTPUT(32),TEMP(84),
      1 ACTUAL(84),EXPECT(84),TEMPBF(9),ISYM(8,84),CVECT(16)
-      INTEGER ERROR,I,N,L,K,INDEX
+      INTEGER*1 IPIN1(84),FNCTBL,NVECT
+      INTEGER*1 I
+      INTEGER ERROR,N,L,K,INDEX
       LOGICAL LFSE(84),LFS1(84),CHECK(84),LTEST(32),TMPHAS(84)
       COMMON /LUNIT/ CONINP,CONOUT,FILINP,FILOUT,PMS,POF,PDF,ROC,RPD
+      CHARACTER*1 MARK,DONT,ZERO,ONE,LOW,
+     1       HIGH,X,BLANK
       DATA MARK/'?'/,DONT/'D'/,ZERO/'0'/,ONE/'1'/,LOW/'L'/,
      1       HIGH/'H'/,X/'X'/,BLANK/' '/
 C
@@ -1777,7 +1883,8 @@
 C THIS SUBROUTINE PUTS THE CVECT INTO TEMP WHICH IS IN FUNCTION
 C TABLE LISTING ORDER
 C
-      INTEGER*1 TEMP(84),IPIN1(84),CVECT(16)
+      CHARACTER*1 TEMP(84),CVECT(16)
+      INTEGER*1 IPIN1(84)
       INTEGER FNCTBL
       LOGICAL LFSE(84),LFS1(84),TMPHAS(84)
       FNCTBL=IPIN1(9)
@@ -1873,9 +1980,11 @@
 C
       IMPLICIT INTEGER*1 (A-Z)
       INTEGER I,J
-      INTEGER*1 TEMPBF(9),ISYM(8,84),IPIN1(84)
+      CHARACTER*1 TEMPBF(9),ISYM(8,84)
+      INTEGER*1 IPIN1(84)
       INTEGER*1 FPTR,SPTR
       LOGICAL LFS1(84),LBAR
+      CHARACTER*1 BAR,BLANK
         DATA BAR/'/'/,BLANK/' '/
       LBAR=.FALSE.
       DO 1 I=1,84
@@ -1908,9 +2017,10 @@
 C
       IMPLICIT INTEGER*1 (A-Z)
       INTEGER I
-      INTEGER*1 FPRE(32),OUTPUT(32),PREOUT(32)
+      CHARACTER*1 FPRE(32),OUTPUT(32),PREOUT(32)
       LOGICAL FLG1,FLG2,FLG3,FLG4
 C
+      CHARACTER*1 D,Z
       DATA D/'D'/,Z/'Z'/
 C
       IF(.NOT.FLG1.AND.(.NOT.FLG2)
@@ -1967,8 +2077,8 @@
 C
 C     I/O UNIT ASSIGNMENTS
 C
-      CONINP=1
-      CONOUT=1
+      CONINP=5
+      CONOUT=6
       FILINP=10
       FILOUT=11
 C
@@ -1982,7 +2092,8 @@
 C     NUMBER WITH ITYPE
       IMPLICIT INTEGER*1 (A-Z)
 C
-      INTEGER I,J,IC,IL,IBLOW,IPCTR,ITYPE
+      INTEGER*2 I,J
+      INTEGER IC,IL,IBLOW,IPCTR,ITYPE
       INTEGER*1 IPAL(3),INAME(5),REST(72),PATN(80),TITLE(80),COMP(80)
       COMMON/SPEC/ IPAL,INAME,REST,PATN,TITLE,COMP
 C
@@ -1998,8 +2109,15 @@
       COMMON /PDS/ LNMAX,LOF,LLN
       COMMON /LINBUF/ CLN,CPG
 C
+      INTEGER*1, PARAMETER :: I2 = ICHAR('2') 
+      INTEGER*1, PARAMETER :: I3 = ICHAR('3') 
+      INTEGER*1, PARAMETER :: I4 = ICHAR('4') 
+      INTEGER*1, PARAMETER :: I6 = ICHAR('6') 
+      INTEGER*1, PARAMETER :: IR = ICHAR('R') 
       DATA INFO
-     1    /'6','4','R','3','2',1/
+     1    /I6 ,I4 ,IR ,I3 ,I2 ,1/
+      INTEGER*2, PARAMETER :: I0 = 0
+      LOGICAL FLFLG
 C
 C     INITIALISE LPOLAR. ALL OUTPUTS ARE ASSUMED TO BE ACTIVE LOW
       DO 10 J=1,84
@@ -2017,7 +2135,7 @@
 C     INITIALIZE LFUSES ARRAY (FUSE ARRAY)
       DO 30 J=1,256
          DO 30 I=1,128
-   30       CALL LFSWRT(I,J,0)
+   30       CALL LFSWRT(I,J,I0)
 C     INITIALIZE IBLOW (NUMBER OF FUSES BLOWN)
       IBLOW=0
       IPCTR=0
@@ -2044,18 +2162,20 @@
 C     THIS SUBROUTINE GETS THE PIN NAME, / IF COMPLEMENT LOGIC, AND
 C      THE FOLLOWING OPERATION SYMBOL IF ANY
       IMPLICIT INTEGER*1 (A-Z)
-      INTEGER I,J,IC,IL
-      INTEGER*1 ISYM(8,84)
+      INTEGER*2 J
+      INTEGER I,IC,IL
+      CHARACTER*1 ISYM(8,84)
       LOGICAL LBLANK,LLEFT,LAND,LOR,LSLASH,LEQUAL,LRIGHT,LXOR,
      1        FLFLG,LFSE(84)
       COMMON  LBLANK,LLEFT,LAND,LOR,LSLASH,LEQUAL,LRIGHT,LXOR
 C
-      INTEGER*1 CPG(9000),CLN(80)
+      CHARACTER*1 CPG(9000),CLN(80)
       INTEGER*2 LOF(350),LLN(350),LNPTR,LNMAX
       COMMON /PDS/ LNMAX,LOF,LLN
       COMMON /LINBUF/ CLN,CPG
       COMMON /LUNIT/ CONINP,CONOUT,FILINP,FILOUT,PMS,POF,PDF,ROC,RPD
 C
+      CHARACTER*1 IBLANK
       DATA IBLANK/' '/
       IF( .NOT.(LLEFT.OR.LAND.OR.LOR.OR.LEQUAL.OR.LRIGHT) )  GO TO 10
       CALL INCR(IC,IL,FLFLG)
@@ -2081,18 +2201,22 @@
 C     A BYPAS FLG TRUE IF THE OUTPUT IS BYPASED
       IMPLICIT INTEGER*1 (A-Z)
       INTEGER IC,IL
-      LOGICAL LBLANK,LLEFT,LAND,LOR,LSLASH,LEQUAL,LRIGHT,LXOR,TAB,
+      LOGICAL LBLANK,LLEFT,LAND,LOR,LSLASH,LEQUAL,LRIGHT,LXOR,
      1        LXOR1,FLFLG,LCOLON
       COMMON  LBLANK,LLEFT,LAND,LOR,LSLASH,LEQUAL,LRIGHT,LXOR
 C
-      INTEGER*1 CPG(9000),CLN(80)
+      CHARACTER*1 CPG(9000),CLN(80)
       INTEGER*2 LOF(350),LLN(350),LNPTR,LNMAX
       COMMON /PDS/ LNMAX,LOF,LLN
       COMMON /LINBUF/ CLN,CPG
       COMMON /LUNIT/ CONINP,CONOUT,FILINP,FILOUT,PMS,POF,PDF,ROC,RPD
 C
+      CHARACTER, PARAMETER :: TABP = CHAR(9)
+      CHARACTER*1 IBLANK,ILEFT,IAND,IOR,COMENT,
+     1     ISLASH,IEQUAL,IRIGHT,ICOLON,TAB
       DATA IBLANK/' '/,ILEFT/'('/,IAND/'*'/,IOR/'+'/,COMENT/';'/,
-     1        ISLASH/'/'/,IEQUAL/'='/,IRIGHT/')'/,ICOLON/':'/,TAB/009/
+     1        ISLASH/'/'/,IEQUAL/'='/,IRIGHT/')'/,ICOLON/':'/,TAB/TABP/
+      CHARACTER*1 CTMP
 C     INITIALLY THE OUTPUT IS ASSUMED TO BE BYPASED BY SETTING FLFLG
 C     TRUE
       FLFLG=.TRUE.
@@ -2140,7 +2264,7 @@
 C      AND THE PIN NAME IN THE PIN LIST OR FUNCTION TABLE PIN LIST
       IMPLICIT INTEGER*1 (A-Z)
       INTEGER I,J,IMATCH
-      INTEGER*1 IBUF(8,84),ISYM(8,84)
+      CHARACTER*1 IBUF(8,84),ISYM(8,84)
       LOGICAL LMATCH
       IMATCH=0
       DO 20 J=1,84
@@ -2161,8 +2285,10 @@
       IMPLICIT INTEGER*1 (A-Z)
       LOGICAL LORARY(2,256),LPOLAR(84),LBYPAS(84)
       COMMON /LFUSE/LORARY,LPOLAR,LBYPAS
-      INTEGER IMATCH,IBUBL,IINPUT,ITYPE
-      INTEGER*1 ITABLE(84),ISYM(8,84)
+      INTEGER*2 IINPUT
+      INTEGER IMATCH,IBUBL,ITYPE
+      CHARACTER*1 ISYM(8,84)
+      INTEGER*2 ITABLE(84)
       LOGICAL LFSE(84),LBUF(84)
       DATA    ITABLE/
      1 2,6,10,14,18,22,26,30,0,0,0,0,0,4,8,12,16,20,24,28,32,
@@ -2252,19 +2378,20 @@
 C     THIS SUBROUTINE PRINTS THE PINOUT OF THE PAL
       IMPLICIT INTEGER*1 (A-Z)
 C
-      INTEGER*1 CPG(9000),CLN(80)
+      CHARACTER*1 CPG(9000),CLN(80)
       INTEGER*2 LOF(350),LLN(350),LNPTR,LNMAX
       COMMON /PDS/ LNMAX,LOF,LLN
       COMMON /LINBUF/ CLN,CPG
       COMMON /LUNIT/ CONINP,CONOUT,FILINP,FILOUT,PMS,POF,PDF,ROC,RPD
 C
-      INTEGER*1 IPAL(3),INAME(5),REST(72),PATN(80),TITLE(80),COMP(80)
+      CHARACTER*1 IPAL(3),INAME(5),REST(72),PATN(80),TITLE(80),COMP(80)
       COMMON/SPEC/ IPAL,INAME,REST,PATN,TITLE,COMP
       INTEGER I,J,II,IC,IL,JJ
-      INTEGER*1 PIN(20,84),IIN(8,2)
+      CHARACTER*1 PIN(42,84),IIN(8,2)
+      CHARACTER*1 IBLANK,ISTAR
       DATA IBLANK/' '/,ISTAR/'*'/
       DO 10 J=1,84
-          DO 5 I=1,20
+          DO 5 I=1,42
     5         PIN(I,J)=IBLANK
 C
    10 CONTINUE
@@ -2339,35 +2466,50 @@
       SUBROUTINE PLOT(LBUF,IBUF,IPROD,LDUMP,ITYPE,LPROD,IOP,IBLOW)
 C     THIS SUBROUTINE PRODUCES THE FUSE PLOT
       IMPLICIT INTEGER*1 (A-Z)
-      INTEGER I,J,IONE,IZERO,IBL,IBUF(8,84)
+      INTEGER ITYPE
+      INTEGER*2 IBL
+      CHARACTER*1 IBUF(8,84)
+      INTEGER*2 J,IONE,IZERO
+      INTEGER I
       INTEGER*1 IOUT(128),IDATA(128)
-      INTEGER IPROD,IBLOW
+      INTEGER*2 IPROD
+      CHARACTER*1 IOP
+      INTEGER IBLOW
       LOGICAL LBUF(84),LDUMP,LPROD(256), FLG1,FLG2
 C
 C
       LOGICAL LORARY(2,256),LPOLAR(84),LBYPAS(84)
       COMMON /LFUSE/LORARY,LPOLAR,LBYPAS
 C
+      CHARACTER*1 IAND,IOR,ISLASH,
+     1     IDASH,X,IBLANK,P,B,
+     2     D,ZERO,ONE,FX,FIDASH
       DATA IAND/'*'/,IOR/'+'/,ISLASH/'/'/,IONE/1/,IZERO/0/,IBL/3/,
      1     IDASH/'-'/,X/'X'/,IBLANK/' '/,P/'P'/,B/'B'/,
      2     D/'D'/,ZERO/'0'/,ONE/'1'/,FX/'0'/,FIDASH/'O'/
       DATA STX/002/,ETX/003/
-      IF(ISVRD(IPROD,1).NE.IBL) RETURN
+      INTEGER*2 ISVRD
+      INTEGER*2 I128
+      DATA I128/128/
+      INTEGER*2 I2TMP
+C
+      IF(ISVRD(IPROD,IONE).NE.IBL) RETURN
       IF(LBUF(1)) GO TO 5
       DO 30 J=1,127
-   30     CALL ISVWRT(IPROD,J,ISVRD(IPROD,J+1))
-      CALL ISVWRT(IPROD,128,IONE)
+   30     CALL ISVWRT(IPROD,J,ISVRD(IPROD,J+IONE))
+      CALL ISVWRT(IPROD,I128,IONE)
     5 DO 20 I=1,8
-         IF( ISVRD(IPROD,1).NE.IBL ) RETURN
+         IF( ISVRD(IPROD,IONE).NE.IBL ) RETURN
           IF( IBUF(I,1).EQ.IBLANK ) GO TO 20
           DO 10 J=1,127
-   10         CALL ISVWRT(IPROD,J,ISVRD(IPROD,J+1))
-          CALL ISVWRT(IPROD,128,IBUF(I,1))
+ 10          CALL ISVWRT(IPROD,J,ISVRD(IPROD,J+IONE))
+          I2TMP=ICHAR(IBUF(I,1))
+          CALL ISVWRT(IPROD,I128,I2TMP)
    20     CONTINUE
-      IF(ISVRD(IPROD,1).NE.IBL) RETURN
+      IF(ISVRD(IPROD,IONE).NE.IBL) RETURN
    40 DO 50 J=1,127
-   50     CALL ISVWRT(IPROD,J,ISVRD(IPROD,J+1))
-      CALL ISVWRT(IPROD,128,IZERO)
+   50     CALL ISVWRT(IPROD,J,ISVRD(IPROD,J+IONE))
+      CALL ISVWRT(IPROD,I128,IZERO)
       RETURN
       END
 C
@@ -2375,10 +2517,11 @@
 C
       SUBROUTINE XPLOT(FLFUSE,IBLOW)
       IMPLICIT INTEGER*1 (A-Z)
-      INTEGER I,J,K,IBLOW,IPROD
+      INTEGER*2 K,IPROD
+      INTEGER I,J,IBLOW
       LOGICAL  FLFUSE(4,2)
       INTEGER  I88PRO
-      INTEGER*1  D(128),P(32),OR(2),F(4)
+      CHARACTER*1  D(128),P(32),OR(2),F(4)
 C
       INTEGER*1 IPAL(3),INAME(5),REST(72),PATN(80),TITLE(80),COMP(80)
       COMMON/SPEC/ IPAL,INAME,REST,PATN,TITLE,COMP
@@ -2387,7 +2530,9 @@
       COMMON /LFUSE/LORARY,LPOLAR,LBYPAS
 C
       COMMON /LUNIT/ CONINP,CONOUT,FILINP,FILOUT,PMS,POF,PDF,ROC,RPD
+      CHARACTER*1 DASH,CROSS,H,L
       DATA     DASH/'-'/,CROSS/'X'/,H/'H'/,L/'L'/
+      LOGICAL LFSRD
 C     THIS SUBROUTINE DISPPALYS THE FUSEPLOT IN '-' AND 'X'
 C     FORMAT. THE INPUT/FEEDBACK PINS ARE GROUPED IN 8. THE
 C     PRODUCT TERMS ARE GROUPED IN 16 FOR EACH PAIR OF OUTPUTS.
@@ -2418,8 +2563,8 @@
       COUNT=I-1
       IPROD=J+COUNT
       DO 5 K=1,128
-      IF(LFSRD(K,IPROD).NE.0) D(K)=DASH
-      IF(LFSRD(K,IPROD).EQ.0) D(K)=CROSS
+      IF(LFSRD(K,IPROD)) D(K)=DASH
+      IF(.NOT.LFSRD(K,IPROD)) D(K)=CROSS
     5 CONTINUE
       DO 6 K=1,2
       IF(LORARY(K,IPROD)) OR(K)=DASH
@@ -2469,7 +2614,7 @@
 C     SAME TIME. NO FEEDBACK PATHS ARE ALLOWED FROM BYPASED OUTPUTS
       IMPLICIT INTEGER*1 (A-Z)
       INTEGER I,J,IMATCH
-      INTEGER*1 ISYM(8,84)
+      CHARACTER*1 ISYM(8,84)
 C
       LOGICAL LORARY(2,256),LPOLAR(84),LBYPAS(84)
       COMMON /LFUSE/LORARY,LPOLAR,LBYPAS
@@ -2561,10 +2706,12 @@
 C      COMPATIBLE WITH THE DATA I/O PROGRAMMABLE LOGIC PAK (PLDS)
 C
       IMPLICIT INTEGER*1 (A-Z)
+      LOGICAL DOIT
       COMMON /LUNIT/ CONINP,CONOUT,FILINP,FILOUT,PMS,POF,PDF,ROC,RPD
 C
-      INTEGER*1 IPBUF(64), IDECIO(5)
-      INTEGER NFUSE,NTEST,IADR,IPT,IINP,PINOUT,I,J,J1,J2,IGH,IMP,ITM,
+      CHARACTER*1 IPBUF(64), IDECIO(5)
+      INTEGER*2 ITM,IINP,IPT
+      INTEGER NFUSE,NTEST,IADR,PINOUT,I,J,J1,J2,IGH,IMP,
      1        MSD
 C
       INTEGER*1 IPAL(3),INAME(5),REST(72),PATN(80),TITLE(80),COMP(80)
@@ -2572,12 +2719,18 @@
 C
       INTEGER*2 PARRY(375)
       LOGICAL LSA01(375,2),LTST(375)
-      COMMON /TEST/ LSA01,LTST,PARRY
+      COMMON /CTEST/ LSA01,LTST,PARRY
 C
       LOGICAL LORARY(2,256),LPOLAR(84),LBYPAS(84)
       COMMON /LFUSE/LORARY,LPOLAR,LBYPAS
 C
-      DATA ZERO/'0'/,ONE/'1'/,SOH/1/,STX/2/,ETX/3/,BEL/7/
+      CHARACTER, PARAMETER :: SOHP = CHAR(1)
+      CHARACTER, PARAMETER :: STXP = CHAR(2)
+      CHARACTER, PARAMETER :: ETXP = CHAR(3)
+      CHARACTER, PARAMETER :: BELP = CHAR(7)
+      CHARACTER*1 ZERO,ONE,SOH,STX,ETX,BEL
+      DATA ZERO/'0'/,ONE/'1'/,SOH/SOHP/,STX/STXP/,ETX/ETXP/,BEL/BELP/
+      LOGICAL LFSRD
 C
       MSD=0
       IADR=0
@@ -2604,7 +2757,7 @@
       DO 50 IINP=1,64
       NFUSE = NFUSE + 1
       IPBUF(NFUSE)=ZERO
-      IF (LFSRD(IINP+ITM,IPT).NE.0) IPBUF(NFUSE)=ONE
+      IF (LFSRD(IINP+ITM,IPT).NEQV..FALSE.) IPBUF(NFUSE)=ONE
    50 CONTINUE
 C
       CALL ENCD(MSD,IADR,IDECIO)
@@ -2664,7 +2817,7 @@
       SUBROUTINE ENCD(MSD,IADR,IDECIO)
 C
       IMPLICIT INTEGER*1 (A-Z)
-      INTEGER*1 ICNV(16),IDECIO(5)
+      CHARACTER*1 ICNV(16),IDECIO(5)
       INTEGER J,IADR,MSD,IDEC(5)
       DATA ICNV/'0','1','2','3','4','5','6','7','8','9',
      1  'A','B','C','D','E','F'/
@@ -2679,7 +2832,3 @@
       END
 C
 C**************************
-$ -1)
-100   IDECIO(J)=ICNV(IDEC(J)+1)
-      IDECIO(1)=ICNV(MSD+1)
-      RET
\ No newline at end of file
